#!/usr/bin/env bash
#
# Cloudcache Unified Infrastructure Management
#
# Single entrypoint for bootstrap, bind, and verify operations
#

set -euo pipefail
IFS=$'\n\t'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check dependencies
command -v jq >/dev/null 2>&1 || die "jq is required (brew install jq)"
command -v wrangler >/dev/null 2>&1 || die "wrangler is required (npm install -g wrangler)"

# Source core library (sets ROOT_DIR)
source "$SCRIPT_DIR/lib/core.sh"

# Ensure ROOT_DIR is set
ROOT_DIR="${ROOT_DIR:-$(cd "$SCRIPT_DIR/.." && pwd)}"

# Load env files
load_env_file_if_exists "$ROOT_DIR/.env"
load_env_file_if_exists "$ROOT_DIR/.env.local"

# Module validation
MODULES=("apex" "app" "admin")
ENVIRONMENTS=("preview" "staging" "prod")

validate_module() {
  local module="$1"
  local found=0
  for m in "${MODULES[@]}"; do
    if [[ "$m" == "$module" ]]; then
      found=1
      break
    fi
  done
  if [[ $found -eq 0 ]]; then
    die "Invalid module: $module. Must be one of: ${MODULES[*]}"
  fi
}

validate_env() {
  local env="$1"
  # Allow "prev" as alias for "preview"
  if [[ "$env" == "prev" ]]; then
    env="preview"
  fi
  local found=0
  for e in "${ENVIRONMENTS[@]}"; do
    if [[ "$e" == "$env" ]]; then
      found=1
      break
    fi
  done
  if [[ $found -eq 0 ]]; then
    die "Invalid environment: $env. Must be one of: preview (or prev), staging, prod"
  fi
  # Return normalized env name
  echo "$env"
}

# Prompt for secret value
prompt_secret() {
  local name="$1"
  local description="${2:-}"
  local value=""
  
  # Simple, clean prompt - just ask for the secret name
  # Use -rs: -r prevents backslash interpretation, -s suppresses echo (silent mode)
  printf "Enter %s: " "$name" >&2
  read -rs value
  echo >&2  # Add newline after silent input
  [[ -n "$value" ]] || die "$name cannot be empty"
  printf "%s" "$value"
}

# Prompt for config value (not secret)
prompt_config() {
  local name="$1"
  local description="${2:-}"
  local value=""
  
  if [[ -n "$description" ]]; then
    echo "$description" >&2
  fi
  
  read -p "Enter $name: " value
  [[ -n "$value" ]] || die "$name cannot be empty"
  printf "%s" "$value"
}

# Get worker name for module and environment
get_worker_name() {
  local module="$1"
  local env="$2"
  
  case "$env" in
    prod)
      echo "${module}-worker"
      ;;
    staging)
      echo "${module}-worker-staging"
      ;;
    preview)
      echo "${module}-worker-preview"
      ;;
    *)
      die "Unknown environment: $env"
      ;;
  esac
}

# Get secrets required for a module (returns space-separated string)
get_module_secrets() {
  local module="$1"
  
  case "$module" in
    app)
      echo "SHOPIFY_API_KEY SHOPIFY_API_SECRET CF_ACCESS_CLIENT_ID CF_ACCESS_CLIENT_SECRET"
      ;;
    admin|apex)
      echo "CF_ACCESS_CLIENT_ID CF_ACCESS_CLIENT_SECRET"
      ;;
    *)
      die "Unknown module: $module"
      ;;
  esac
}

# Bootstrap command: create infrastructure and set up secrets
cmd_bootstrap() {
  local module="${1:-}"
  local env="${2:-}"
  
  [[ -n "$module" ]] || die "Usage: bootstrap <module> <env>"
  [[ -n "$env" ]] || die "Usage: bootstrap <module> <env>"
  
  validate_module "$module"
  # Normalize env (prev -> preview)
  env=$(validate_env "$env")
  
  setup_cf_env
  setup_wrangler_token
  
  step "Bootstrapping $module for $env environment"
  
  # For Workers: use wrangler deploy to create/update
  if [[ "$module" != "apex" ]]; then
    local worker_name
    worker_name=$(get_worker_name "$module" "$env")
    
    step "Deploying Worker: $worker_name"
    local wrangler_toml="$ROOT_DIR/apps/$module/wrangler.toml"
    
    if [[ "$env" == "prod" ]]; then
      run wrangler deploy --config "$wrangler_toml"
    else
      run wrangler deploy --config "$wrangler_toml" --env "$env"
    fi
  else
    # For APEX: create Pages project if needed
    step "Setting up Pages project: apex-cloudcache"
    
    # Check if project exists
    local projects
    projects=$(cf_get "${CF_ACCT_BASE}/pages/projects" 2>/dev/null || echo '{"result":[]}')
    
    local project_exists
    project_exists=$(echo "$projects" | jq -r '.result[] | select(.name=="apex-cloudcache") | .name' || echo "")
    
    if [[ -z "$project_exists" ]]; then
      step "Creating Pages project: apex-cloudcache"
      local project_data
      project_data=$(jq -n '{
        name: "apex-cloudcache",
        production_branch: "main"
      }')
      cf_post "${CF_ACCT_BASE}/pages/projects" "$project_data" >/dev/null
      log "Pages project created"
    else
      log "Pages project already exists"
    fi
  fi
  
  log "Bootstrap complete. Run 'bind' command to set secrets."
}

# Bind command: set secrets for a module/environment
cmd_bind() {
  local module="${1:-}"
  local env="${2:-}"
  
  [[ -n "$module" ]] || die "Usage: bind <module> <env>"
  [[ -n "$env" ]] || die "Usage: bind <module> <env>"
  
  validate_module "$module"
  # Normalize env (prev -> preview)
  env=$(validate_env "$env")
  
  setup_cf_env
  setup_wrangler_token
  
  if [[ "$module" == "apex" ]]; then
    # Pages environment variables
    step "Setting Pages environment variables"
    
    local cf_access_id cf_access_secret
    cf_access_id=$(prompt_secret "CF_ACCESS_CLIENT_ID")
    cf_access_secret=$(prompt_secret "CF_ACCESS_CLIENT_SECRET")
    
    # Map env to Pages env name
    local pages_env="production"
    case "$env" in
      staging) pages_env="staging" ;;
      preview) pages_env="preview" ;;
    esac
    
    local env_data
    env_data=$(jq -n --arg id "$cf_access_id" --arg secret "$cf_access_secret" '{
      vars: {
        CF_ACCESS_CLIENT_ID: $id,
        CF_ACCESS_CLIENT_SECRET: $secret
      }
    }')
    
    cf_put "${CF_ACCT_BASE}/pages/projects/apex-cloudcache/env/$pages_env" "$env_data" >/dev/null || \
      cf_post "${CF_ACCT_BASE}/pages/projects/apex-cloudcache/env/$pages_env" "$env_data" >/dev/null
    
    log "Pages environment variables set for $pages_env"
  else
    # Worker secrets
    local worker_name
    worker_name=$(get_worker_name "$module" "$env")
    
    local secrets_str
    secrets_str=$(get_module_secrets "$module")
    
    # Convert space-separated string to array
    # Save and restore IFS to handle spaces correctly
    local old_ifs="$IFS"
    IFS=' '
    local secrets_array=($secrets_str)
    IFS="$old_ifs"
    
    for secret_name in "${secrets_array[@]}"; do
      local secret_value
      secret_value=$(prompt_secret "$secret_name")
      
      step "Setting $secret_name for $worker_name (will overwrite if exists)"
      
      # wrangler secret put reads from stdin
      # Note: This will overwrite/replace any existing secret with the same name
      # For production, use --env="" to explicitly target top-level environment
      # For staging/preview, use --env to let wrangler use the name from config file
      if [[ "$env" == "prod" ]]; then
        echo "$secret_value" | wrangler secret put "$secret_name" --name "$worker_name" --env "" --config "$ROOT_DIR/apps/$module/wrangler.toml" || die "Failed to set secret $secret_name"
      else
        # Don't pass --name when using --env; wrangler uses name from config file's [env.*] section
        echo "$secret_value" | wrangler secret put "$secret_name" --env "$env" --config "$ROOT_DIR/apps/$module/wrangler.toml" || die "Failed to set secret $secret_name"
      fi
      
      log "Secret $secret_name set (overwritten if it existed)"
    done
  fi
  
  log "Secrets bound successfully"
}

# Verify command: check infrastructure and secrets
cmd_verify() {
  local module="${1:-}"
  local env="${2:-}"
  
  [[ -n "$module" ]] || die "Usage: verify <module> <env>"
  [[ -n "$env" ]] || die "Usage: verify <module> <env>"
  
  validate_module "$module"
  # Normalize env (prev -> preview)
  env=$(validate_env "$env")
  
  setup_cf_env
  setup_wrangler_token
  
  step "Verifying $module ($env)"
  
  if [[ "$module" == "apex" ]]; then
    # Check Pages project
    local project
    project=$(cf_get "${CF_ACCT_BASE}/pages/projects/apex-cloudcache" 2>/dev/null || echo "")
    
    if [[ -z "$project" ]]; then
      die "Pages project 'apex-cloudcache' not found"
    fi
    
    log "Pages project exists: apex-cloudcache"
    
    # Check environment variables
    local pages_env="production"
    case "$env" in
      staging) pages_env="staging" ;;
      preview) pages_env="preview" ;;
    esac
    
    local env_vars
    env_vars=$(cf_get "${CF_ACCT_BASE}/pages/projects/apex-cloudcache/env/$pages_env" 2>/dev/null || echo '{"vars":{}}')
    
    local has_id has_secret
    has_id=$(echo "$env_vars" | jq -r '.vars.CF_ACCESS_CLIENT_ID // empty' || echo "")
    has_secret=$(echo "$env_vars" | jq -r '.vars.CF_ACCESS_CLIENT_SECRET // empty' || echo "")
    
    if [[ -n "$has_id" && -n "$has_secret" ]]; then
      log "Environment variables set for $pages_env"
    else
      die "Missing environment variables for $pages_env"
    fi
  else
    # Check Worker
    local worker_name
    worker_name=$(get_worker_name "$module" "$env")
    
    step "Checking Worker: $worker_name"
    
    local deployments
    deployments=$(wrangler deployments list --name "$worker_name" --config "$ROOT_DIR/apps/$module/wrangler.toml" 2>/dev/null || echo "")
    
    if [[ -z "$deployments" ]]; then
      die "Worker '$worker_name' not found or not deployed"
    fi
    
    log "Worker exists: $worker_name"
    
    # Check secrets
    local secrets_str
    secrets_str=$(get_module_secrets "$module")
    
    # Convert space-separated string to array
    local old_ifs="$IFS"
    IFS=' '
    local secrets_array=($secrets_str)
    IFS="$old_ifs"
    
    local missing_secrets=""
    for secret_name in "${secrets_array[@]}"; do
      local secret_list
      if [[ "$env" == "prod" ]]; then
        secret_list=$(wrangler secret list --name "$worker_name" --config "$ROOT_DIR/apps/$module/wrangler.toml" 2>/dev/null || echo "[]")
      else
        # Don't pass --name when using --env; wrangler uses name from config file's [env.*] section
        secret_list=$(wrangler secret list --env "$env" --config "$ROOT_DIR/apps/$module/wrangler.toml" 2>/dev/null || echo "[]")
      fi
      
      # Parse JSON output and check if secret exists
      local secret_exists
      secret_exists=$(echo "$secret_list" | jq -r --arg name "$secret_name" '.[]? | select(.name==$name) | .name' 2>/dev/null || echo "")
      
      if [[ -z "$secret_exists" ]]; then
        missing_secrets="$missing_secrets $secret_name"
      fi
    done
    
    if [[ -n "$missing_secrets" ]]; then
      die "Missing secrets:$missing_secrets"
    fi
    
    log "All secrets present"
  fi
  
  log "Verification complete"
}

# Main command dispatcher
main() {
  local command="${1:-}"
  
  case "$command" in
    bootstrap)
      shift
      cmd_bootstrap "$@"
      ;;
    bind)
      shift
      cmd_bind "$@"
      ;;
    verify)
      shift
      cmd_verify "$@"
      ;;
    *)
      echo "Usage: $0 {bootstrap|bind|verify} <module> <env>" >&2
      echo "" >&2
      echo "Commands:" >&2
      echo "  bootstrap  Create/update infrastructure (Workers/Pages)" >&2
      echo "  bind        Set secrets interactively" >&2
      echo "  verify      Verify infrastructure and secrets" >&2
      echo "" >&2
      echo "Modules: apex, app, admin" >&2
      echo "Environments: preview (or prev), staging, prod" >&2
      exit 1
      ;;
  esac
}

main "$@"

